EC 4.4: How to improve end-to-end latency of chains?

Currently, the EDF scheduling approach we use is chain-agnostic, in that it only cares about individual deadlines. If we wanted to improve the end-to-end latency of chains, we could make it chain-aware by taking into account `chain_id` and `chain_pos` whe nassigning priorities. We could:
    1. favor earlier stages so that data flows through the pipeline faster
    2. partition end-to-end deadlines across chains rather than giving each task independent deadlines
Making these changes would reduce e2e latency because, suppose we have task chain T with tasks t1->t2->t3. If t2 cannot make progress until t1 produces its output, if the scheduler runs t2 first (which is possible given the arbitrary deadlines), t2 would immediately block or spin waiting for data from t1, meaning CPU resources are guaranteed to be wasted. With these changes, we know t1 will always run before t2, so t2 will never have the chance to block the CPU and waste resources.

Writeup 4.5:

Q1. What is the difference between partitioned and global multi-processor scheduling? What are the
pros and cons of each?

Partitioned multi-processor scheduling statically binds each task to a single processor. Because each task is predictably bound, it is an ideal candidate for hard real-time systems that need guaranteed deadlines and simple analysis. One major drawback is that it can easily lead to processor imbalance if the tasks aren't distributed in a near-optimal way.

Global multi-processor scheduling holds a global queue from which any processor can run a task. This improves the overall load balancing issues from partitioned scheduling, but introduces higher runtime overhead from context switching and migration.


Q2. Explain your task partitioning strategy. List which tasks you assigned to Core 0 and Core 1, and
show that the utilization on each core is <= 1.0



Q3. Please measure the overhead of your EDF scheduling implementation in the Kernel space? Was it
acceptable?



Q4. How did you implement the e2e latency measurement? Specifically, where in the kernel are the
start and end times captured, and how did you handle synchronization between cores?



Q5. What issues did you face for this project and how did you resolve them?


